# Landing Zone Terraform

This folder contains a root Terraform module that wires together child modules for network, AKS, Key Vault, Service Principal, and monitoring (Prometheus + Grafana) creation.

Quick start (local):

1. cd landing-zone
2. Ensure Terraform and Azure CLI are installed and on PATH
3. az login
4. az account set --subscription "GSL research dev test"
5. terraform init
6. terraform plan -out plan.tfplan
7. terraform apply "plan.tfplan"

What the files are for
- `terraform.tfvars` ‚Äì concrete variable values used by Terraform. Useful for local runs; do NOT commit secrets.
- `terraform.tfvars.example` ‚Äì example/template values you can copy and edit to `terraform.tfvars`.
- `run-terraform.ps1` ‚Äì optional PowerShell helper that runs `terraform init`, `validate`, `plan` and (optionally) `apply`. You can delete it and run the commands manually; the file is provided for convenience.

Why keep both `terraform.tfvars` and `terraform.tfvars.example`?
- `terraform.tfvars.example` is safe to check into source control. It documents the variables and provides sane defaults.
- `terraform.tfvars` contains your real values. Keep it out of version control (add to .gitignore) when it contains secrets.

Monitoring
- The monitoring module installs `kube-prometheus-stack` (Prometheus + Grafana) via the Helm provider into AKS.
- Grafana admin password is generated by Terraform and stored in Key Vault (secret name: `grafana-admin-password`).
- Grafana is configured with Ingress enabled by default in the module's values template. Customize `modules/monitoring/values.yaml.tpl` for specific ingress hosts/annotations.

Notes / Next steps
1. CI/CD: I can add Azure DevOps or GitHub Actions workflows that run `terraform fmt`, `terraform init -backend-config=...`, `terraform plan`, and `terraform apply` with approvals.
2. Remote backend: I recommend using an Azure Storage Account backend for team state. I can add a bootstrap script to create the storage account and container.

Your manual notes (preserved):
- preferred chart: kube-prometheus-stack
- expose Grafana: Ingress
- add a sample Grafana admin password stored in Key Vault
# Landing Zone Terraform

This folder contains a root Terraform module that wires together child modules for network, AKS, Key Vault and Service Principal creation.

Quick start:

1. cd landing-zone
2. terraform init
3. terraform plan
4. terraform apply


# Use a backend.tf with remote state in Azure

Don't forget to secure your Terraform state:

terraform {
  backend "azurerm" {
    resource_group_name  = "tfstate-rg"
    storage_account_name = "tfstate123"
    container_name       = "tfstate"
    key                  = "terraform.tfstate"
  }
}


Make sure this storage account has private access, encryption, and versioning.

# Add Monitoring
preferred chart: kube-prometheus-stack
 expose Grafana:  Ingress
 add a sample Grafana admin password stored in Key Vault

 add Prometheus + Grafana as a Terraform child module (deploy via Helm provider into the AKS cluster). If yes, would you like:
Prometheus Operator + Grafana via the Helm chart (recommended)

# When I get this situated figure out 
1. how to connect this with Azure Devops and like Github Actions and like the CICD format
2. ADD A REMOTE BACKEND WITH A STORAGE ACCOUNT SECURELY



# Description
You're provisioning a secure, monitored, production-ready AKS environment, and automating it all with Terraform. Here's a one-liner for each:

Resource Group ‚Äì Organizes everything

Virtual Network/Subnet ‚Äì Isolates resources securely

AKS Cluster ‚Äì Runs your containerized workloads

Service Principal ‚Äì Authenticates automation

Key Vault ‚Äì Secures secrets

Random Password ‚Äì Creates strong credentials automatically

Helm Prometheus Stack ‚Äì Adds observability (metrics, dashboards, alerts)

Outputs ‚Äì Gives you key deployment data


# Pipeline.yaml
| Feature                                  | Description                                                   |
| ---------------------------------------- | ------------------------------------------------------------- |
| üîê Manual Approval via `terraform_apply` | Prevents auto-deploying unreviewed infra                      |
| üîê Key Vault usage in Terraform          | Passwords like Grafana admin stored securely                  |
| üîê SystemAssigned identity for AKS       | Managed identity improves security over client secrets        |
| üîê Sensitive outputs marked in Terraform | Ensures secrets aren‚Äôt exposed accidentally                   |
| üîê ACR login via `az acr login`          | Uses Azure RBAC, not username/password                        |
| üîê Separate CI/CD steps                  | Follows DevSecOps structure: validate ‚Üí plan ‚Üí apply ‚Üí deploy |
A full Azure Landing Zone ready to host microservices

Observability (Prometheus & Grafana) already running

CI/CD pipeline to:
Update your infrastructure (Terraform)
Build and deploy your apps (Docker + Helm)
Secure key management via Key Vault
Clean separation of environments/stages

# NEXT
‚úÖ How to structure a multi-environment landing zone pipeline (dev/stage/prod)
Deploying on AKS with Helm, Namespaces, and Autoscaling!!!!




‚úÖ Terraform backend config in Azure Storage( WHICH PUTS THE tfstate in BLOB!!!!!!!!!!)
‚úÖ State locking with Azure Blob + key

FOR production
Using Managed Identity or Service Principal with restricted permissions is considered secure and follows Azure best practices.

- script: |
    terraform init \
      -backend-config="resource_group_name=terraform-state-rg" \
      -backend-config="storage_account_name=tfstatecontoso" \
      -backend-config="container_name=tfstate" \
      -backend-config="key=landing-zone.tfstate"
You can also extract the backend config to a separate backend.tfvars file and reference that.

Add backend block in Terraform

In your Terraform config folder (e.g. landing-zone/), create or update:

main.tf or backend.tf:

terraform {
  backend "azurerm" {
    resource_group_name  = "terraform-state-rg"
    storage_account_name = "tfstatecontoso"
    container_name       = "tfstate"
    key                  = "landing-zone.tfstate"  # This is the blob name
  }
}


‚ùóÔ∏è Do not pass secrets (like account keys) in this file. Terraform will prompt for them or you can pass via environment.

# Create rg, storage account(--encryption-services blob), blob container

üîí Terraform State Locking

When using Azure Blob Storage with the azurerm backend:
State locking is automatically handled using Azure Blob Lease mechanism
If two users try to apply, one will be blocked until the lease is released

We have to create first before we run
so do a terraform before this for backend or
# Variables (replace as needed)
RESOURCE_GROUP_NAME="terraform-state-rg"
STORAGE_ACCOUNT_NAME="tfstatecontoso"
CONTAINER_NAME="tfstate"
LOCATION="westus"

# Create resource group
az group create -n $RESOURCE_GROUP_NAME -l $LOCATION

# Create storage account
az storage account create \
  -n $STORAGE_ACCOUNT_NAME \
  -g $RESOURCE_GROUP_NAME \
  -l $LOCATION \
  --sku Standard_LRS \
  --encryption-services blob

# Create blob container
az storage container create \
  --name $CONTAINER_NAME \
  --account-name $STORAGE_ACCOUNT_NAME


# Assign a Managed Identity to the resource running Terraform

For example, if you're running Terraform in an Azure VM or Azure DevOps Pipeline hosted agent with Managed Identity enabled.

# Assign Role to Managed Identity

Give the Managed Identity Storage Blob Data Contributor role on the storage account (or resource group) containing the tfstate blob.

az role assignment create --assignee <managed-identity-client-id> \
  --role "Storage Blob Data Contributor" \
  --scope "/subscriptions/<subscription-id>/resourceGroups/<rg-name>/providers/Microsoft.Storage/storageAccounts/<storage-account-name>"


Configure Terraform backend without credentials

In your backend.tf or wherever you configure backend:

terraform {
  backend "azurerm" {
    resource_group_name  = "terraform-state-rg"
    storage_account_name = "tfstatecontoso"
    container_name       = "tfstate"
    key                  = "terraform.tfstate"
  }
}


No client_id or secret is needed. Terraform running under Managed Identity will authenticate automatically.


Create a Service Principal

az ad sp create-for-rbac --name "terraform-backend-sp" --role "Storage Blob Data Contributor" \
  --scopes "/subscriptions/<subscription-id>/resourceGroups/<rg-name>/providers/Microsoft.Storage/storageAccounts/<storage-account-name>" \
  --sdk-auth


The --sdk-auth flag outputs JSON with client ID, secret, tenant ID, etc.

Set Environment Variables

In your CI/CD pipeline or local environment, export the following variables (replace with actual values):

export ARM_CLIENT_ID="xxxx-xxxx-xxxx-xxxx"
export ARM_CLIENT_SECRET="your-secret"
export ARM_TENANT_ID="xxxx-xxxx-xxxx-xxxx"
export ARM_SUBSCRIPTION_ID="your-subscription-id"


Terraform uses these automatically for authentication.

Configure Terraform backend

Same as before, no credentials in the backend config:

terraform {
  backend "azurerm" {
    resource_group_name  = "terraform-state-rg"
    storage_account_name = "tfstatecontoso"
    container_name       = "tfstate"
    key                  = "terraform.tfstate"
  }
}
